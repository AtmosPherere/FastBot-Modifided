// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WIDGETREUSEMODEL_FASTBOTX_H_
#define FLATBUFFERS_GENERATED_WIDGETREUSEMODEL_FASTBOTX_H_

#include "flatbuffers/flatbuffers.h"

namespace fastbotx {

struct WidgetCount;
struct WidgetCountBuilder;

struct ActivityWidgetMap;
struct ActivityWidgetMapBuilder;

struct ReuseEntry;
struct ReuseEntryBuilder;

struct WidgetReuseModel;
struct WidgetReuseModelBuilder;

struct WidgetCount FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WidgetCountBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDGET_HASH = 4,
    VT_COUNT = 6
  };
  uint64_t widget_hash() const {
    return GetField<uint64_t>(VT_WIDGET_HASH, 0);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_WIDGET_HASH) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
};

struct WidgetCountBuilder {
  typedef WidgetCount Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_widget_hash(uint64_t widget_hash) {
    fbb_.AddElement<uint64_t>(WidgetCount::VT_WIDGET_HASH, widget_hash, 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(WidgetCount::VT_COUNT, count, 0);
  }
  explicit WidgetCountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WidgetCount> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WidgetCount>(end);
    return o;
  }
};

inline flatbuffers::Offset<WidgetCount> CreateWidgetCount(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t widget_hash = 0,
    int32_t count = 0) {
  WidgetCountBuilder builder_(_fbb);
  builder_.add_widget_hash(widget_hash);
  builder_.add_count(count);
  return builder_.Finish();
}

struct ActivityWidgetMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivityWidgetMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVITY = 4,
    VT_WIDGETS = 6
  };
  const flatbuffers::String *activity() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTIVITY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fastbotx::WidgetCount>> *widgets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fastbotx::WidgetCount>> *>(VT_WIDGETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIVITY) &&
           verifier.VerifyString(activity()) &&
           VerifyOffset(verifier, VT_WIDGETS) &&
           verifier.VerifyVector(widgets()) &&
           verifier.VerifyVectorOfTables(widgets()) &&
           verifier.EndTable();
  }
};

struct ActivityWidgetMapBuilder {
  typedef ActivityWidgetMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activity(flatbuffers::Offset<flatbuffers::String> activity) {
    fbb_.AddOffset(ActivityWidgetMap::VT_ACTIVITY, activity);
  }
  void add_widgets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fastbotx::WidgetCount>>> widgets) {
    fbb_.AddOffset(ActivityWidgetMap::VT_WIDGETS, widgets);
  }
  explicit ActivityWidgetMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ActivityWidgetMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivityWidgetMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivityWidgetMap> CreateActivityWidgetMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> activity = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fastbotx::WidgetCount>>> widgets = 0) {
  ActivityWidgetMapBuilder builder_(_fbb);
  builder_.add_widgets(widgets);
  builder_.add_activity(activity);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActivityWidgetMap> CreateActivityWidgetMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *activity = nullptr,
    const std::vector<flatbuffers::Offset<fastbotx::WidgetCount>> *widgets = nullptr) {
  auto activity__ = activity ? _fbb.CreateString(activity) : 0;
  auto widgets__ = widgets ? _fbb.CreateVector<flatbuffers::Offset<fastbotx::WidgetCount>>(*widgets) : 0;
  return fastbotx::CreateActivityWidgetMap(
      _fbb,
      activity__,
      widgets__);
}

struct ReuseEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReuseEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_ACTIVITIES = 6
  };
  uint64_t action() const {
    return GetField<uint64_t>(VT_ACTION, 0);
  }
  bool KeyCompareLessThan(const ReuseEntry *o) const {
    return action() < o->action();
  }
  int KeyCompareWithValue(uint64_t val) const {
    return static_cast<int>(action() > val) - static_cast<int>(action() < val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fastbotx::ActivityWidgetMap>> *activities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fastbotx::ActivityWidgetMap>> *>(VT_ACTIVITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ACTION) &&
           VerifyOffset(verifier, VT_ACTIVITIES) &&
           verifier.VerifyVector(activities()) &&
           verifier.VerifyVectorOfTables(activities()) &&
           verifier.EndTable();
  }
};

struct ReuseEntryBuilder {
  typedef ReuseEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(uint64_t action) {
    fbb_.AddElement<uint64_t>(ReuseEntry::VT_ACTION, action, 0);
  }
  void add_activities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fastbotx::ActivityWidgetMap>>> activities) {
    fbb_.AddOffset(ReuseEntry::VT_ACTIVITIES, activities);
  }
  explicit ReuseEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReuseEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReuseEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReuseEntry> CreateReuseEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t action = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fastbotx::ActivityWidgetMap>>> activities = 0) {
  ReuseEntryBuilder builder_(_fbb);
  builder_.add_action(action);
  builder_.add_activities(activities);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReuseEntry> CreateReuseEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t action = 0,
    const std::vector<flatbuffers::Offset<fastbotx::ActivityWidgetMap>> *activities = nullptr) {
  auto activities__ = activities ? _fbb.CreateVector<flatbuffers::Offset<fastbotx::ActivityWidgetMap>>(*activities) : 0;
  return fastbotx::CreateReuseEntry(
      _fbb,
      action,
      activities__);
}

struct WidgetReuseModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WidgetReuseModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<fastbotx::ReuseEntry>> *model() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fastbotx::ReuseEntry>> *>(VT_MODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyVector(model()) &&
           verifier.VerifyVectorOfTables(model()) &&
           verifier.EndTable();
  }
};

struct WidgetReuseModelBuilder {
  typedef WidgetReuseModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fastbotx::ReuseEntry>>> model) {
    fbb_.AddOffset(WidgetReuseModel::VT_MODEL, model);
  }
  explicit WidgetReuseModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WidgetReuseModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WidgetReuseModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<WidgetReuseModel> CreateWidgetReuseModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fastbotx::ReuseEntry>>> model = 0) {
  WidgetReuseModelBuilder builder_(_fbb);
  builder_.add_model(model);
  return builder_.Finish();
}

inline flatbuffers::Offset<WidgetReuseModel> CreateWidgetReuseModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<fastbotx::ReuseEntry>> *model = nullptr) {
  auto model__ = model ? _fbb.CreateVectorOfSortedTables<fastbotx::ReuseEntry>(model) : 0;
  return fastbotx::CreateWidgetReuseModel(
      _fbb,
      model__);
}

inline const fastbotx::WidgetReuseModel *GetWidgetReuseModel(const void *buf) {
  return flatbuffers::GetRoot<fastbotx::WidgetReuseModel>(buf);
}

inline const fastbotx::WidgetReuseModel *GetSizePrefixedWidgetReuseModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<fastbotx::WidgetReuseModel>(buf);
}

inline bool VerifyWidgetReuseModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fastbotx::WidgetReuseModel>(nullptr);
}

inline bool VerifySizePrefixedWidgetReuseModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fastbotx::WidgetReuseModel>(nullptr);
}

inline void FinishWidgetReuseModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fastbotx::WidgetReuseModel> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWidgetReuseModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fastbotx::WidgetReuseModel> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fastbotx

#endif  // FLATBUFFERS_GENERATED_WIDGETREUSEMODEL_FASTBOTX_H_
